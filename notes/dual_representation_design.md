# Decoupled Hierarchy Data Structure

**Ticket**: [FEATURE-Dual-Representation]

**Status**: In Progress

**Author**: Gemini

**Date**: 2026-01-07

## 1. Overview

This document outlines a design for a new data structure to represent and manipulate multiple, co-existing folder hierarchies. The primary goal is to cleanly separate an object's intrinsic data from its contextual place in a given tree structure. This allows for flexible and efficient manipulation of hierarchies on the frontend, such as displaying an "original" and "mutable" view of a file system side-by-side.

This design is conceptually similar to how Git manages files:
*   **An object database** stores the core data (the "blobs").
*   **Tree objects** provide structure and name files, pointing to the blobs.
*   **Commits** describe changes to the trees.

Our design will use an `ItemStore` for the core data, `Hierarchy` objects for the tree structures, and `HierarchyDiff`s for the changes.

## 2. Problem Statement

The previous folder structure representation was monolithic. A single, deeply nested JSON object described the entire hierarchy, and each node in the tree contained all the data for that file or folder. This created several challenges:

*   **Inflexibility**: It was impossible to represent the same file in two different places (e.g., in its original file system location and in a new categorized view) without duplicating its data.
*   **No Contextual State**: There was no way for a file to have different properties in different trees. For example, renaming a file in a "mutable" categorized view would be difficult to manage without affecting its "original" name.
*   **Inefficient Mutations**: Any change to the hierarchy (renaming, moving a file) required complex manipulation of the large, nested state object on the frontend and sending the entire new tree back to the backend, which is inefficient and error-prone.
*   **Poor Separation of Concerns**: Intrinsic file data (e.g., its original path) was mixed with its contextual role in a specific tree structure.

## 3. Proposed Solution: The Decoupled Hierarchy Model

I propose a new data model that decouples content from presentation. This structure is composed of two main parts:

1.  **`ItemStore`**: A flat dictionary that acts as the single source of truth for the intrinsic, shared properties of every object (file, folder, or category). This is analogous to Git's object database.
2.  **`Hierarchy`**: A tree structure that defines parent-child relationships and holds contextual properties (like `name`) for items as they appear *in that specific tree*. This is analogous to a Git tree object.

### 3.1. Data Structure Definitions

#### ID Generation

To ensure unique and traceable identifiers, the `id` for items in the `ItemStore` will be generated by prefixing the database primary key with the type of the item (e.g., `"node-123"`, `"category-456"`).

#### Frontend (TypeScript)

```typescript
/**
 * Intrinsic, shared data for an underlying file, folder, or category.
 * Lives in the ItemStore. This data is considered context-independent.
 */
interface HierarchyItem {
  id: string;          // Unique, persistent ID (e.g., "node-123"). The primary link.
  type: 'node' | 'category';
  originalPath?: string; // An immutable property of a file node.
  // Other shared metadata can go here...
}

type ItemStore = Record<string, HierarchyItem>;

/**
 * Represents an item's instance *within a specific tree*. 
 * It holds context-dependent properties, like its name in that tree.
 */
interface HierarchyRecord {
  itemId: string;      // Foreign key pointing to the HierarchyItem in the ItemStore.
  name: string;        // The name of this item *in this tree*. This can be mutated.
  children: HierarchyRecord[];
  metadata?: Record<string, any>; // Other tree-specific metadata.
}

/**
 * A complete, self-contained hierarchy (e.g., "original" or "mutable_categorized").
 */
interface Hierarchy {
  stage: string;
  root: HierarchyRecord;
}

/**
 * The complete API payload, containing the shared items and one or more hierarchies.
 */
interface DualRepresentation {
  items: ItemStore;
  hierarchies: Record<string, Hierarchy>; // e.g., { "original": Hierarchy, "mutable": Hierarchy }
}

/**
 * A lightweight object describing changes made to a Hierarchy.
 * Analogous to a git diff or commit.
 */
interface HierarchyDiff {
  added: Record<string, string[]>;    // Key: Parent ID, Value: Child IDs to add.
  deleted: Record<string, string[]>;  // Key: Parent ID, Value: Child IDs to remove.
  // updated: Record<string, { name?: string }>; // Future: To support renaming
}
```

#### Backend (Python/Pydantic)

```python
from enum import Enum
from typing import Any, Dict, List, Optional
from pydantic import BaseModel

class ItemType(str, Enum):
    NODE = "node"
    CATEGORY = "category"

class PipelineStage(str, Enum):
    ORIGINAL = "original"
    GROUPED = "grouped"
    ORGANIZED = "organized"

# Intrinsic, shared data
class HierarchyItem(BaseModel):
    id: str
    type: ItemType
    originalPath: Optional[str] = None
    # Other metadata...

# Contextual, tree-specific data
class HierarchyRecord(BaseModel):
    itemId: str
    name: str
    children: List["HierarchyRecord"] = []
    metadata: Dict[str, Any] = {}

# A complete tree structure
class Hierarchy(BaseModel):
    stage: PipelineStage
    source_type: ItemType
    root: HierarchyRecord

# The full API payload
class DualRepresentation(BaseModel):
    items: Dict[str, HierarchyItem]
    hierarchies: Dict[str, Hierarchy]

# A lightweight change description
class HierarchyDiff(BaseModel):
    added: Dict[str, List[str]]
    deleted: Dict[str, List[str]]
```

### 3.2. Key Features and Implementation

#### Representing Multiple Views

The "dual representation" concept is achieved by packaging the shared `ItemStore` with two or more `Hierarchy` objects inside the `DualRepresentation` payload. For example, the backend can provide an `original` hierarchy and a `categorized` hierarchy. Because they both reference the same `ItemStore`, the frontend can efficiently render both views without duplicating core data.

#### Contextual Naming and Mutation

Because the `name` property now lives in the `HierarchyRecord`, a file can have different names in different trees. A user can rename an item in the mutable `categorized` hierarchy without affecting its name in the `original` hierarchy. This is a critical feature for allowing users to organize files without altering the source file system's structure.

#### Synchronized Highlighting

When a user interacts with a `HierarchyRecord` in one view, the frontend can get its `itemId`. This ID serves as a universal key to find the corresponding `HierarchyItem` in the `ItemStore` or to find all other `HierarchyRecord`s in other visible hierarchies that share the same `itemId`. This makes synchronized highlighting trivial.

#### Tracking Edits as Diffs

When a user modifies a hierarchy (e.g., by dragging and dropping a file), the frontend does not need to send the entire modified tree back to the server. It instead generates a `HierarchyDiff` object describing only what changed (e.g., item 'node-123' was removed from parent 'category-A' and added to parent 'category-B'). This is highly efficient and aligns with the "git commit" analogy.

### 3.3. Approach to Backwards Compatibility

This new design is a significant departure from the old `FolderV2` structure. Backwards compatibility should be approached pragmatically, serving as a temporary bridge rather than a permanent constraint on the new system.

#### Explicit Use Cases for Compatibility

1.  **Frontend Feature Flag**: The entire new dual representation UI will be conditionally rendered based on a feature flag. This is the most important form of compatibility, as it allows the stable, existing import wizard to coexist with the new experimental version, providing a zero-risk fallback for users.

2.  **Data Structure Converters**: To support gradual migration, it can be useful to create temporary, isolated utility functions that convert the new `DualRepresentation` format *into* the old `FolderV2` format. This allows components that have not yet been migrated to the new data model to continue functioning. These converters act as a compatibility adapter layer and should be clearly marked for future deprecation.

#### Pitfalls to Avoid

To prevent "over-engineering" and ensure the new design remains clean, we must avoid the following:

*   **Do Not Pollute the New API**: The `/api/v2/folder-structure` endpoint must **only** return the new, clean `DualRepresentation` model. It should not be modified with special flags or parameters to return the old `FolderV2` format. The V1 and V2 APIs should remain completely separate.

*   **Do Not Complicate New Data Models**: The new TypeScript and Pydantic models (`HierarchyItem`, `HierarchyRecord`, etc.) must not be contaminated with legacy fields from the old `FolderV2` structure. The responsibility of mapping between the two models belongs exclusively to the temporary converter utilities.

*   **Isolate Compatibility Logic**: Any backend logic for converting to the old format should be kept separate from the primary `build_dual_representation` logic. The goal is to eventually delete the compatibility helpers, and they should not be entangled with the core, forward-looking implementation.

## 4. Migration Path

The migration will focus on changing how data is fetched and manipulated, rather than on database schema changes, as the databases will be re-created.

### 4.1. Backend Changes

1.  **New API Endpoint**:
    *   Create a new API endpoint (e.g., `/api/v2/folder-structure`) that returns the `DualRepresentation` structure.
    *   The existing `calculate_folder_structure_for_stage` function in `organizer/utils/folder_structure.py` will need to be adapted or replaced.

2.  **Data Transformation Logic**:
    *   The core of the work on the backend will be to create a function that queries the `index.db` for nodes and the `work.db` for categories (`GroupCategory` and `GroupCategoryEntry`) and transforms them into the `DualRepresentation` format.
    *   This will involve:
        *   Querying all relevant `Node` and `GroupCategory` objects.
        *   Populating the `items` store with `HierarchyItem` objects (removing `name` and other contextual data).
        *   Building the `HierarchyRecord` trees for each stage, correctly populating `itemId` and `name`.

3.  **Diff Application Endpoint**:
    *   Create a new endpoint (e.g., `PATCH /api/v2/folder-structure`) that accepts a `HierarchyDiff` object.
    *   This endpoint will contain the logic to translate the ID-based diffs into changes in the backend's database tables (e.g., updating `GroupCategoryEntry` records).

### 4.2. Frontend Changes

1.  **API Service Layer**:
    *   Update the API service layer in `frontend/src/api.ts` to call the new `/api/v2/folder-structure` endpoint.

2.  **State Management**:
    *   The frontend state management (e.g., in `useFolderTree.ts` or a similar hook) will need to be updated to store the `DualRepresentation` object.
    *   Instead of a single nested tree, the state will now consist of the `items` store and the two `hierarchy` maps.

3.  **Component Rendering**:
    *   The components that render the folder trees (e.g., `FolderBrowser.tsx`) will need to be rewritten to render a hierarchy from the `ItemStore` and a `Hierarchy` map.
    *   The rendering logic will be recursive, but instead of traversing a nested object, it will look up items in the `ItemStore` and their children in the `Hierarchy` map.

4.  **User Interaction Logic**:
    *   The logic for handling user interactions like drag-and-drop will need to be updated to generate `HierarchyDiff` objects instead of directly mutating the state.

## 5. Discarded Alternatives

### Alternative 1: Continue Using a Nested Tree Structure

*   **Description**: Continue to use a deeply nested JSON object to represent the hierarchy, but add the diffing mechanism.
*   **Reason for Discarding**: This would still be inefficient for the frontend to manage. Manipulating large nested structures is complex and prone to errors. The dual representation with flattened items is a more modern and scalable approach for frontend state management.

### Alternative 2: GraphQL

*   **Description**: Use GraphQL to allow the frontend to query the exact hierarchy shape it needs.
*   **Reason for Discarding**: While GraphQL is powerful, it would introduce a significant amount of new complexity and infrastructure to the project (a GraphQL server, schema definitions, new client-side libraries). The proposed REST-based solution is simpler to implement and achieves the primary goals with less overhead.

## 6. Metrics and Logging

To evaluate user behavior and understand common operations, the backend will log every `HierarchyDiff` object it successfully processes. This data will be invaluable for future improvements and for understanding how users are organizing their files.

### 6.1. Log Storage

A new table, `log_hierarchy_diff`, will be added to the `work.db` database to store these diffs in a structured format. Storing the diffs in the database (as opposed to a plain text log file) allows for easier querying and aggregation.

The SQLAlchemy model for this table will be:

```python
from datetime import datetime
from sqlalchemy import ForeignKey
from sqlalchemy.orm import Mapped, mapped_column
from storage.db_types import DateTime, JsonDict

class HierarchyDiffLog(WorkBase):
    __tablename__ = "log_hierarchy_diff"

    id: Mapped[int] = mapped_column(primary_key=True, autoincrement=True)
    run_id: Mapped[int] = mapped_column(ForeignKey("run.id"))
    created_at: Mapped[datetime] = mapped_column(DateTime, default=datetime.utcnow)
    diff: Mapped[dict] = mapped_column(JsonDict) # The HierarchyDiff object
```

### 6.2. Logging Process

1.  When the backend receives a `PATCH /api/v2/folder-structure` request, it will first validate the `HierarchyDiff` object.
2.  If the diff is valid and successfully applied, the backend will create a new `HierarchyDiffLog` entry.
3.  The `run_id` will be associated with the current user session/run.
4.  The entire `HierarchyDiff` object will be stored in the `diff` column as a JSON object.

### 6.3. Example Log Analysis

With this data, we can answer questions like:

*   What are the most common operations (e.g., additions vs. deletions)?
*   Which categories are most frequently edited?
*   What is the average size of a diff (i.e., how many changes do users make at once)?

This quantitative insight into user workflows will be a powerful tool for guiding future development.

## 7. Acceptance Criteria

*   A design document (this file) is created and reviewed.
*   The backend provides a new API endpoint that serves the `DualRepresentation` structure.
*   The backend provides an endpoint to receive and apply `HierarchyDiff` objects.
*   The backend logs every successfully applied `HierarchyDiff` to a new `log_hierarchy_diff` table in `work.db`.
*   The frontend is migrated to use the new data structure for displaying and interacting with folder hierarchies.
*   The application allows for side-by-side display of the "node" and "category" hierarchies, with synchronized highlighting for both files and folders.
*   User edits to the category hierarchy are tracked as diffs and successfully sent to the backend.
*   The core functionality of the application (browsing, organizing files) remains intact and is enhanced by the new design.
