# Dual Representation Data Structure for Folder Hierarchies

**Ticket**: [FEATURE-Dual-Representation]

**Status**: To Do

**Author**: Gemini

**Date**: 2026-01-06

## 1. Overview

This document outlines a design for a new data structure to represent folder hierarchies in the fs-organizer application. The goal is to create a "dual representation" that is more flexible and efficient for both the frontend (React) and backend (Python API), and to define a migration path from the existing structure.

The new data structure will be used to represent two types of hierarchical data:

1.  **Nodes**: The raw file system structure, ingested directly.
2.  **Categories**: A derived structure where files are organized by semantic categories.

This design enables features like synchronized highlighting between the two views and tracking of user modifications as diffs.

## 2. Problem Statement

The current folder structure representation is coupled to the specific implementation in `organizer/utils/folder_structure.py`. The frontend receives a deeply nested JSON object, which can be cumbersome to manipulate and update. Key challenges with the current approach include:

*   **Inefficiency**: Transmitting the entire tree structure for any change is bandwidth-intensive and slow.
*   **State Management**: Managing and manipulating a large, nested tree on the frontend is complex.
*   **Lack of Flexibility**: The current structure makes it difficult to represent multiple, interconnected hierarchies (e.g., the original file structure and the categorized structure).
*   **Difficulty Tracking Changes**: There is no clear mechanism for tracking user-driven changes to the hierarchy in a way that can be easily applied on the backend.

## 3. Proposed Solution: Dual Representation Stack

I propose a new data structure, the "Dual Representation Stack," which separates the identity of nodes and categories from their hierarchical arrangement. This structure will be composed of two main parts:

1.  **Item Store**: A flattened map (or dictionary) of all items (nodes and categories), indexed by a unique ID.
2.  **Hierarchy Store**: A map representing the hierarchical relationships between items, using only their IDs.

### 3.1. Data Structure Definitions

#### ID Generation

To ensure unique and traceable identifiers, the `id` for `HierarchyItem` objects will be generated by prefixing the database primary key with the type of the item. For example:
*   A `Node` with `id=123` will have a `HierarchyItem` ID of `"node-123"`.
*   A `GroupCategory` with `id=456` will have a `HierarchyItem` ID of `"category-456"`.

This approach guarantees uniqueness across both nodes and categories.

#### Frontend (TypeScript)

```typescript
// Represents either a file/directory from the filesystem (Node) or a semantic category.
// Files are always leaf nodes. ZIP files are treated as folders.
interface HierarchyItem {
  id: string; // e.g., "node-123", "category-abc"
  name: string;
  type: 'node' | 'category';
  originalPath?: string; // For nodes
  // Other metadata...
}

// Stores all items in a flattened structure for quick lookup.
type ItemStore = Record<string, HierarchyItem>;

// Represents the parent-child relationships using IDs.
// The key is the parent ID, and the value is an array of child IDs.
type Hierarchy = Record<string, string[]>;

// The complete data structure sent from the backend.
interface DualRepresentation {
  items: ItemStore;
  nodeHierarchy: Hierarchy;
  categoryHierarchy: Hierarchy;
}

// Represents changes made by the user on the frontend (moving nodes between categories).
// Reordering of children within a category is not supported.
interface HierarchyDiff {
  // Key: Parent ID. Value: An array of child IDs that were added.
  added: Record<string, string[]>;
  // Key: Parent ID. Value: An array of child IDs that were removed.
  deleted: Record<string, string[]>;
}
```

#### Backend (Python/Pydantic)

The backend will generate this structure and apply diffs received from the frontend.

```python
from typing import Dict, List, Literal, Optional

from pydantic import BaseModel

class HierarchyItem(BaseModel):
    id: str
    name: str
    type: Literal['node', 'category']
    originalPath: Optional[str] = None
    # Other metadata...

class DualRepresentation(BaseModel):
    items: Dict[str, HierarchyItem]
    node_hierarchy: Dict[str, List[str]]
    category_hierarchy: Dict[str, List[str]]

class HierarchyDiff(BaseModel):
    added: Dict[str, List[str]]
    deleted: Dict[str, List[str]]
```

### 3.2. Key Features and Implementation

#### Dual Representation

The `DualRepresentation` object will contain two hierarchy maps: `nodeHierarchy` and `categoryHierarchy`.

*   `nodeHierarchy`: Represents the original file system structure. The `items` store will contain entries for all files and directories, and this hierarchy will link them.
*   `categoryHierarchy`: Represents the semantically categorized structure. The `items` store will also contain entries for the categories themselves. Files will always be leaf nodes in this hierarchy.

This allows the frontend to render both hierarchies from a single, consistent data source.

#### Synchronized Highlighting

When a user clicks on an item (file or folder) in one hierarchy, the frontend can easily find the corresponding item in the other hierarchy. Since both hierarchies share the same `ItemStore`, if an item (which can be a node representing a file or a folder, or a category) is part of both hierarchies, it will have the same ID. This makes cross-hierarchy interaction straightforward for both files and folders.

For example, if a user clicks on a file or folder in the `categoryHierarchy`, the frontend can get its ID and then use that ID to find and highlight the same item in the `nodeHierarchy`.

#### Tracking Edits as Diffs

When a user modifies a hierarchy (e.g., by dragging and dropping a file into a different category), the frontend will not mutate the original `categoryHierarchy` directly. Instead, it will record the changes in a `HierarchyDiff` object.

*   When a node is moved, it is removed from its old parent's child list and added to the new parent's child list. These changes are recorded in the `deleted` and `added` fields of the `HierarchyDiff`.

When the user saves their changes, the frontend sends only the `HierarchyDiff` object to the backend. The backend is then responsible for interpreting this diff and applying it to its own representation of the hierarchy (e.g., updating the `GroupCategoryEntry` table in the `work.db`). If the diff is invalid (e.g., refers to a non-existent ID), the backend will reject the entire diff with an error response.

This approach is efficient as it avoids sending the entire hierarchy back to the server. It's also robust, as the backend can validate the changes before applying them.

## 4. Migration Path

The migration will focus on changing how data is fetched and manipulated, rather than on database schema changes, as the databases will be re-created.

### 4.1. Backend Changes

1.  **New API Endpoint**:
    *   Create a new API endpoint (e.g., `/api/v2/folder-structure`) that returns the `DualRepresentation` structure.
    *   The existing `calculate_folder_structure_for_stage` function in `organizer/utils/folder_structure.py` will need to be adapted or replaced.

2.  **Data Transformation Logic**:
    *   The core of the work on the backend will be to create a function that queries the `index.db` for nodes and the `work.db` for categories (`GroupCategory` and `GroupCategoryEntry`) and transforms them into the `DualRepresentation` format.
    *   This will involve:
        *   Querying all relevant `Node` and `GroupCategory` objects.
        *   Populating the `items` store with `HierarchyItem` objects.
        *   Building the `nodeHierarchy` from the `parent_node_id` relationships in the `Node` table.
        *   Building the `categoryHierarchy` from the relationships in the `GroupCategoryEntry` table.

3.  **Diff Application Endpoint**:
    *   Create a new endpoint (e.g., `PATCH /api/v2/folder-structure`) that accepts a `HierarchyDiff` object.
    *   This endpoint will contain the logic to translate the ID-based diffs into changes in the backend's database tables (e.g., updating `GroupCategoryEntry` records).

### 4.2. Frontend Changes

1.  **API Service Layer**:
    *   Update the API service layer in `frontend/src/api.ts` to call the new `/api/v2/folder-structure` endpoint.

2.  **State Management**:
    *   The frontend state management (e.g., in `useFolderTree.ts` or a similar hook) will need to be updated to store the `DualRepresentation` object.
    *   Instead of a single nested tree, the state will now consist of the `items` store and the two `hierarchy` maps.

3.  **Component Rendering**:
    *   The components that render the folder trees (e.g., `FolderBrowser.tsx`) will need to be rewritten to render a hierarchy from the `ItemStore` and a `Hierarchy` map.
    *   The rendering logic will be recursive, but instead of traversing a nested object, it will look up items in the `ItemStore` and their children in the `Hierarchy` map.

4.  **User Interaction Logic**:
    *   The logic for handling user interactions like drag-and-drop will need to be updated to generate `HierarchyDiff` objects instead of directly mutating the state.

## 5. Discarded Alternatives

### Alternative 1: Continue Using a Nested Tree Structure

*   **Description**: Continue to use a deeply nested JSON object to represent the hierarchy, but add the diffing mechanism.
*   **Reason for Discarding**: This would still be inefficient for the frontend to manage. Manipulating large nested structures is complex and prone to errors. The dual representation with flattened items is a more modern and scalable approach for frontend state management.

### Alternative 2: GraphQL

*   **Description**: Use GraphQL to allow the frontend to query the exact hierarchy shape it needs.
*   **Reason for Discarding**: While GraphQL is powerful, it would introduce a significant amount of new complexity and infrastructure to the project (a GraphQL server, schema definitions, new client-side libraries). The proposed REST-based solution is simpler to implement and achieves the primary goals with less overhead.

## 6. Metrics and Logging

To evaluate user behavior and understand common operations, the backend will log every `HierarchyDiff` object it successfully processes. This data will be invaluable for future improvements and for understanding how users are organizing their files.

### 6.1. Log Storage

A new table, `log_hierarchy_diff`, will be added to the `work.db` database to store these diffs in a structured format. Storing the diffs in the database (as opposed to a plain text log file) allows for easier querying and aggregation.

The SQLAlchemy model for this table will be:

```python
from datetime import datetime
from sqlalchemy import ForeignKey
from sqlalchemy.orm import Mapped, mapped_column
from storage.db_types import DateTime, JsonDict

class HierarchyDiffLog(WorkBase):
    __tablename__ = "log_hierarchy_diff"

    id: Mapped[int] = mapped_column(primary_key=True, autoincrement=True)
    run_id: Mapped[int] = mapped_column(ForeignKey("run.id"))
    created_at: Mapped[datetime] = mapped_column(DateTime, default=datetime.utcnow)
    diff: Mapped[dict] = mapped_column(JsonDict) # The HierarchyDiff object
```

### 6.2. Logging Process

1.  When the backend receives a `PATCH /api/v2/folder-structure` request, it will first validate the `HierarchyDiff` object.
2.  If the diff is valid and successfully applied, the backend will create a new `HierarchyDiffLog` entry.
3.  The `run_id` will be associated with the current user session/run.
4.  The entire `HierarchyDiff` object will be stored in the `diff` column as a JSON object.

### 6.3. Example Log Analysis

With this data, we can answer questions like:

*   What are the most common operations (e.g., additions vs. deletions)?
*   Which categories are most frequently edited?
*   What is the average size of a diff (i.e., how many changes do users make at once)?

This quantitative insight into user workflows will be a powerful tool for guiding future development.

## 7. Acceptance Criteria

*   A design document (this file) is created and reviewed.
*   The backend provides a new API endpoint that serves the `DualRepresentation` data structure.
*   The backend provides an endpoint to receive and apply `HierarchyDiff` objects.
*   The backend logs every successfully applied `HierarchyDiff` to a new `log_hierarchy_diff` table in `work.db`.
*   The frontend is migrated to use the new data structure for displaying and interacting with folder hierarchies.
*   The application allows for side-by-side display of the "node" and "category" hierarchies, with synchronized highlighting for both files and folders.
*   User edits to the category hierarchy are tracked as diffs and successfully sent to the backend.
*   The core functionality of the application (browsing, organizing files) remains intact and is enhanced by the new design.
